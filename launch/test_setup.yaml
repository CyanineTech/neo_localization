
# exponential low pass gain for localization updates (0 to 1)
#   (higher gain means odometry is less used / relied on)
update_gain: 0.5

# time based confidence gain when in 2D / 1D mode
confidence_gain: 0.01

# map tile size in pixels
map_size: 1000

# how often to downscale (half) the original map
map_downscale: 0

# how many 3x3 gaussian smoothing iterations are applied to the map
num_smooth: 5

# how many particles (samples) to spread for each scan / update
sample_rate: 10

# odometry error in x and y [m/m] [1]
#    how fast to increase particle spread when in 1D / 0D mode
odometry_std_xy: 0.01

# odometry error in yaw angle [rad/rad] [1]
#    how fast to increase particle spread when in 0D mode
odometry_std_yaw: 0.01

# minimum particle spread in x and y [m]
min_sample_std_xy: 0.025

# minimum particle spread in yaw angle [rad]
min_sample_std_yaw: 0.025

# initial/maximum particle spread in x and y [m]
max_sample_std_xy: 0.5

# initial/maximum particle spread in yaw angle [rad]
max_sample_std_yaw: 0.5

# threshold for 1D / 2D decision making (maximum ratio of optimized vs. seed variance)
#   if worst sigma ratio is above this value we go into 1D mode
#   if both sigma ratios are above we may go into 0D mode, depending on disable_threshold
#   lower values will make it go into 1D / 0D mode earlier
constrain_threshold: 0.3

# threshold for 2D / 0D decision making (minimum ratio of best score vs. mean score)
#   higher values will make it go into 0D mode earlier
#   threshold of 1.0 means we never go into 0D mode
disable_threshold: 1.1

# solver update gain, lower gain = more stability / slower convergence
solver_gain: 0.1

# solver update damping, higher damping = more numeric stability / slower convergence
solver_damping: 1000

# number of gauss-newton iterations per sample per scan
solver_iterations: 20

# if to broadcast map frame
broadcast_tf: true

